import argcomplete
import argparse
import asyncio
import pathlib
import re

import click

from betsy_ros import ROSInterface, get_ros_version, get_workspace_root
from betsy_ros.interfaces import list_interfaces as list_ros_interfaces  # Avoid backwards incompatible name

from ros_command.command_lib import get_output, run
from ros_command.completion import PackageCompleter, Completer


ACTION_PARTS = ['Goal', 'Result', 'Feedback']
ACTION_LINE = '# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======'

COMMENT_PATTERN = re.compile(r'^([^#]*[^#\s])?'  # The contents of the line (no #, does not end in whitespace)
                             r'(\s*#.*)$')       # Any leading whitespace, a # then the comment contents

FIELD_LINE = re.compile(r'(?P<field_type>[\w_/]+)'  # geometry_msgs/Point
                        r'(?P<array>\[\d*\])?'  # [4]
                        r'\s+'
                        r'(?P<name>[\w_]+)'  # points
                        r'\s*=?\s*'
                        r'(?P<value>.*)?'
                        r'$',
                        re.DOTALL)
PRIMITIVES = ['bool',
              'byte',
              'int8', 'uint8',
              'int16', 'uint16',
              'int32', 'uint32',
              'int64', 'uint64',
              'float32', 'float64',
              'string',
              'time', 'duration'
              ]


def get_action_parts(base_interface):
    for action_part in ACTION_PARTS:
        yield ROSInterface(base_interface.package, 'msg', f'{base_interface.name}{action_part}')


class InterfaceInterface:
    def __init__(self, version, distro, interface_type):
        self.version = version
        self.distro = distro
        self.interface_type = interface_type
        self.interface_definition_cache = {}

    def get_base_command(self, verb, interface_type=None, filter_flag=False):
        if interface_type is None:
            interface_type = self.interface_type
        if self.version == 1:
            return [f'/opt/ros/{self.distro}/bin/ros{interface_type}', verb]
        else:
            cmd = [f'/opt/ros/{self.distro}/bin/ros2', 'interface', verb]
            if filter_flag:
                cmd.append('-' + interface_type[0])  # -m for msg, -s for srv, etc
            return cmd

    def parse_interface(self, s, interface_type=None):
        return ROSInterface.from_string(s, interface_type or self.interface_type)

    def list_interfaces(self, name_filter=None):
        # Implemented with underlying logic to avoid await command
        interfaces = list(list_ros_interfaces(self.version, [self.interface_type]))

        if name_filter is None:
            return interfaces

        filtered = []
        for interface in interfaces:
            if interface.name == name_filter:
                filtered.append(interface)
        return filtered

    def translate_to_full_names(self, base_s):
        pieces = base_s.split('/')

        # If no /, then only the interface name is specified and list all the interfaces that have the same name
        if len(pieces) == 1:
            return self.list_interfaces(base_s)
        else:
            return [self.parse_interface(base_s)]

    async def get_interface_definition(self, interface):
        command = self.get_base_command('show', interface_type=interface.type)
        if self.version == 1:
            command.append('-r')  # Raw flag (to preserve comments)
            command.append(interface.to_string())
        else:
            command.append(interface.to_string(two_part=False))
        ret, output, err = await get_output(command)
        if err:
            click.secho(err, fg='red')
        return output.strip().split('\n')

    async def display_type(self, interface, indentation=0, recurse=False, comments=True):
        if interface not in self.interface_definition_cache:
            self.interface_definition_cache[interface] = await self.get_interface_definition(interface)

        for line in self.interface_definition_cache[interface]:
            if line == ACTION_LINE:
                continue
            elif not comments and line.strip() and line.strip()[0] == '#':
                continue

            click.secho(' ' * indentation, nl=False)
            m = COMMENT_PATTERN.match(line)
            if m:
                line, comment = m.groups()
                line = line or ''
            else:
                comment = None

            sub_interface = None
            m = FIELD_LINE.match(line)
            if m:
                fields = m.groupdict()
                if fields['field_type'] not in PRIMITIVES:
                    if '/' not in fields['field_type']:
                        # Determine inferred package
                        name = fields['field_type']
                        if name == 'Header':
                            pkg = 'std_msgs'
                        else:
                            pkg = interface.package

                        sub_interface = ROSInterface(pkg, 'msg', name)
                        fields['field_type'] = str(sub_interface)
                    else:
                        sub_interface = self.parse_interface(fields['field_type'], 'msg')

                click.secho(fields['field_type'], nl=False)
                if fields['array']:
                    click.secho(fields['array'], nl=False)
                click.secho(' ' + fields['name'], nl=False, fg='bright_white')
                if fields['value']:
                    click.secho(' = ', nl=False)
                    click.secho(fields['value'], fg='cyan', nl=False)
            elif line == '---':
                click.secho(line, nl=False, fg='blue')
            else:
                click.secho(line, nl=False)
            if not comments:
                click.secho('')  # Newline
            else:
                click.secho(comment, fg='green')

            if recurse and sub_interface:
                await self.display_type(sub_interface, indentation + 4, recurse, comments)

    async def list_packages(self, interface_type=None):
        # List all packages with any messages
        _, out, _ = await get_output(self.get_base_command('packages', interface_type))
        return sorted(set(filter(None, out.split('\n'))))

    async def list_actions(self, pkg=None):
        if pkg:
            packages = [pkg]
        else:
            packages = await self.list_packages('msg')

        results = []
        for pkg in packages:
            _, path_s, _ = await get_output([f'/opt/ros/{self.distro}/bin/rospack', 'find', pkg])
            path = pathlib.Path(path_s.strip()) / 'action'
            if path.exists():
                for filename in path.glob('*.action'):
                    results.append(ROSInterface(pkg, 'action', filename.stem))
        return sorted(results)


class InterfaceCompleter(Completer):
    def __init__(self, workspace_root, interface_interface):
        super().__init__(workspace_root, interface_interface.version)
        self.interface_interface = interface_interface

    def get_cache_keys(self, **kwargs):
        return [str(self.workspace_root), self.interface_interface.interface_type]

    def get_completions(self, **kwargs):
        return [interface.to_string(two_part=self.version == 1)
                for interface in self.interface_interface.list_interfaces()]

    def filter_values(self, values, prefix=None, **kwargs):
        matches = []
        for full_name in values:
            interface = ROSInterface.from_string(full_name, interface_type=self.interface_interface.interface_type)

            if prefix:
                if interface.name.startswith(prefix):
                    # If the name matches the prefix, add interface by name
                    matches.append(interface.name)
                elif full_name.startswith(prefix):
                    # If the full name matches the prefix, add the interface's full name
                    matches.append(full_name)

                # if the prefix exists and does not match either condition, add nothing
            else:
                # If there is no prefix, add the interface by name and full_name
                matches.append(interface.name)
                matches.append(full_name)

        return matches


async def main(interface_type):
    build_type, workspace_root = get_workspace_root()
    version, distro = get_ros_version()

    ii = InterfaceInterface(version, distro, interface_type)

    interface_completer = InterfaceCompleter(workspace_root, ii)

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest='verb')
    show_parser = subparsers.add_parser('show', aliases=['info'])
    show_parser.add_argument('interface_name').completer = interface_completer
    show_parser.add_argument('-r', '--recurse', action='store_true')
    show_parser.add_argument('-c', '--ignore-comments', action='store_true')
    subparsers.add_parser('list')
    md5_parser = subparsers.add_parser('md5')
    md5_parser.add_argument('interface_name').completer = interface_completer
    pkg_parser = subparsers.add_parser('package')
    pkg_parser.add_argument('package_name').completer = PackageCompleter(workspace_root)
    proto_parser = subparsers.add_parser('proto')
    proto_parser.add_argument('interface_name').completer = interface_completer
    subparsers.add_parser('packages')

    argcomplete.autocomplete(parser)

    args = parser.parse_args()
    if args.verb == 'info':  # Alias
        args.verb = 'show'

    if version == 1 and interface_type == 'action':
        # ROS 1 does not support action commands natively.
        if args.verb == 'show':
            for interface in ii.translate_to_full_names(args.interface_name):
                click.secho(f'[{interface}]', fg='blue')
                for component in get_action_parts(interface):
                    await ii.display_type(component, recurse=args.recurse, comments=not args.ignore_comments)
                    if not component.name.endswith('Feedback'):
                        click.secho('---', fg='blue')
        elif args.verb == 'md5':
            interface = ii.parse_interface(args.interface_name)
            for component in get_action_parts(interface):
                name = str(component)
                cmd = ii.get_base_command(args.verb, interface_type='msg')
                cmd.append(name)
                click.secho(f'[{name}] ', nl=False)
                await run(cmd)
        elif args.verb == 'list':
            for interface in await ii.list_actions():
                print(interface)
        elif args.verb == 'package':
            for interface in await ii.list_actions(pkg=args.package_name):
                print(interface)
        elif args.verb == 'packages':
            pkgs = set(interface.package for interface in await ii.list_actions())
            print('\n'.join(sorted(pkgs)))
        elif args.verb == 'proto':
            raise NotImplementedError('Proto is not implemented for ROS 1, although it could be.')
        else:
            raise RuntimeError(f'Unknown verb "{args.verb}" for ROS 1 action')

    elif args.verb == 'show':
        for interface in ii.translate_to_full_names(args.interface_name):
            click.secho(f'[{interface}]', fg='blue')
            await ii.display_type(interface, recurse=args.recurse, comments=not args.ignore_comments)
    elif args.verb in ['list', 'packages']:
        # Pass through to ros2 interface with appropriate args
        command = ii.get_base_command(args.verb, filter_flag=True)
        await run(command)
    elif version == 1:
        # Pass through for rosmsg/rossrv
        cmd = ii.get_base_command(args.verb)
        if args.verb == 'md5':
            cmd.append(args.interface_name)
        elif args.verb == 'package':
            cmd.append(args.package_name)
        elif args.verb == 'proto':
            raise NotImplementedError('Proto is not implemented for ROS 1, although it could be.')

        code = await run(cmd)
        exit(code)

    elif args.verb == 'package':
        command = ii.get_base_command('package')
        command.append(args.package_name)
        _, out, _ = await get_output(command)
        # ROS 2 does not provide the type-specific flags for this command (yet) so
        # for now we manually filter out the interfaces with the wrong type
        for interface in map(ii.parse_interface, filter(None, sorted(out.split('\n')))):
            if interface.type == interface_type:
                print(interface)
    elif args.verb == 'proto':
        full_names = ii.translate_to_full_names(args.interface_name)
        if not full_names:
            click.secho(f'Cannot find interface "{args.interface_name}"', fg='red')
            exit(-1)
        elif len(full_names) > 1:
            click.secho(f'Interface "{args.interface_name}" is ambiguous. Options:', fg='yellow')
            for interface in full_names:
                click.secho(f' - {interface}', fg='yellow')
            exit(-1)

        command = ii.get_base_command('proto')
        command.append(full_names[0].to_string(two_piece=False))
        await run(command)
    else:
        raise NotImplementedError('No equivalent md5 command in ros2')


def main_msg():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(main('msg'))


def main_srv():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(main('srv'))


def main_action():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(main('action'))
